$date
   Sat Apr  5 22:17:21 2025
$end
$version
  2018.2
$end
$timescale
  1ps
$end
$scope module RISC_CPU_TB $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module uut $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 5 % add_pc_out [4:0] $end
$var wire 5 & operand_addr [4:0] $end
$var wire 5 ' selected_addr [4:0] $end
$var wire 5 ( add_pc_in [4:0] $end
$var wire 8 ) instruction [7:0] $end
$var wire 8 * data_out [7:0] $end
$var wire 8 + data_in [7:0] $end
$var wire 8 , alu_out [7:0] $end
$var wire 8 - acc_out [7:0] $end
$var wire 3 . opcode [2:0] $end
$var wire 1 / is_zero $end
$var wire 1 0 sel $end
$var wire 1 1 rd $end
$var wire 1 2 wr $end
$var wire 1 3 ld_ir $end
$var wire 1 4 halt $end
$var wire 1 5 inc_pc $end
$var wire 1 6 ld_ac $end
$var wire 1 7 ld_pc $end
$var wire 1 8 data_e $end
$scope module Top1 $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 1 7 ld_pc $end
$var wire 1 5 inc_pc $end
$var wire 1 4 halt $end
$var wire 5 ( add_pc_in [4:0] $end
$var reg 5 9 add_pc_out [4:0] $end
$upscope $end
$scope module Top2 $end
$var wire 1 0 sel $end
$var wire 5 % add_pc_out [4:0] $end
$var wire 5 & operand_addr [4:0] $end
$var reg 5 : selected_addr [4:0] $end
$var parameter 32 ; WIDTH [31:0] $end
$upscope $end
$scope module Top3 $end
$var wire 1 # clk $end
$var wire 1 1 rd $end
$var wire 1 2 wr $end
$var wire 1 4 halt $end
$var wire 5 ' selected_addr [4:0] $end
$var wire 1 8 data_e $end
$var wire 8 + data_in [7:0] $end
$var reg 8 < data_out [7:0] $end
$var reg 8 = instruction [7:0] $end
$upscope $end
$scope module Top4 $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 1 3 ld_ir $end
$var wire 8 ) instruction [7:0] $end
$var reg 5 > operand_addr [4:0] $end
$var reg 3 ? opcode [2:0] $end
$upscope $end
$scope module Top5 $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 8 , alu_out [7:0] $end
$var wire 1 6 ld_ac $end
$var reg 8 @ acc_out [7:0] $end
$upscope $end
$scope module Top6 $end
$var wire 3 . opcode [2:0] $end
$var wire 8 * data_out [7:0] $end
$var wire 8 - acc_out [7:0] $end
$var reg 8 A alu_out [7:0] $end
$var reg 1 B is_zero $end
$upscope $end
$scope module Top7 $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 3 . opcode [2:0] $end
$var wire 1 / is_zero $end
$var wire 1 0 hazard_checked $end
$var reg 1 C sel $end
$var reg 1 D rd $end
$var reg 1 E wr $end
$var reg 1 F ld_ir $end
$var reg 1 G halt $end
$var reg 1 H inc_pc $end
$var reg 1 I ld_ac $end
$var reg 1 J ld_pc $end
$var reg 1 K data_e $end
$var reg 1 L stall $end
$var reg 3 M state [2:0] $end
$var parameter 3 N INST_ADDR [2:0] $end
$var parameter 3 O INST_FETCH [2:0] $end
$var parameter 3 P INST_LOAD [2:0] $end
$var parameter 3 Q IDLE [2:0] $end
$var parameter 3 R OP_ADDR [2:0] $end
$var parameter 3 S OP_FETCH [2:0] $end
$var parameter 3 T ALU_OP [2:0] $end
$var parameter 3 U STORE [2:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0!
1"
0#
1$
bx %
bx &
bx '
bz (
bx )
bx *
bz +
bx ,
bx -
bx .
x/
z0
x1
x2
x3
x4
x5
x6
x7
x8
bx 9
bx :
b101 ;
bx <
bx =
bx >
bx ?
bx @
bx A
xB
xC
xD
xE
xF
xG
xH
xI
xJ
xK
xL
bx M
b0 N
b1 O
b10 P
b11 Q
b100 R
b101 S
b110 T
b111 U
$end
#5000
1!
1#
b0 %
b0 &
b0 '
b0 ,
b0 -
b0 .
1/
11
02
03
04
05
06
07
08
b0 9
b0 :
b0 >
b0 ?
b0 @
b0 A
1B
1C
0D
0E
0F
0G
0H
0I
0J
0K
0L
b0 M
#10000
0!
0"
0#
0$
#15000
1!
1#
1C
b1 M
#20000
0!
0#
#25000
1!
1#
12
1C
1D
b10 M
#30000
0!
0#
#35000
1!
1#
14
1C
1D
1F
b11 M
#40000
0!
0#
#45000
1!
1#
